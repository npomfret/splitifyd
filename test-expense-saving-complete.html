<!DOCTYPE html>
<html>
<head>
    <title>Complete Expense Saving Tests</title>
</head>
<body>
    <h1>Complete Expense Saving Fix Verification</h1>
    <p>Check the console to see test output</p>
    <button onclick="runComprehensiveTests()">Run Comprehensive Tests</button>
    
    <script src="js/utils.js"></script>
    <script src="js/cache.js"></script>
    <script src="js/sync.js"></script>
    <script src="js/app.js"></script>
    <script>
        function getMockExpense(overrides = {}) {
            return {
                description: 'Test Expense',
                amount: 50.00,
                currency: 'USD',
                paidBy: 'member-123',
                splitBetween: ['member-123', 'member-456'],
                category: 'Food',
                ...overrides
            };
        }
        
        function getMockProject(overrides = {}) {
            return {
                id: '507f1f77bcf86cd799439011',
                name: 'Test Project',
                created: new Date().toISOString(),
                members: {
                    'member-123': {
                        id: 'member-123',
                        name: 'Test User',
                        joined: new Date().toISOString(),
                        addedBy: 'user-123',
                        active: true
                    },
                    'member-456': {
                        id: 'member-456',
                        name: 'Test User 2',
                        joined: new Date().toISOString(),
                        addedBy: 'user-123',
                        active: true
                    }
                },
                expenses: {},
                settlements: {},
                edits: [],
                ...overrides
            };
        }
        
        function setupTestEnvironment() {
            // Clear localStorage
            localStorage.clear();
            
            // Initialize app with test data
            App.currentUser = {
                id: 'user-123',
                name: 'Test User',
                projects: ['507f1f77bcf86cd799439011'],
                lastCurrency: 'USD'
            };
            
            App.currentProject = getMockProject();
            
            // Initialize cache
            Cache.init();
            Cache.saveProject(App.currentProject.id, App.currentProject);
        }
        
        async function runComprehensiveTests() {
            console.log('=== Running Comprehensive Expense Saving Tests ===\n');
            
            let testsPassed = 0;
            let testsTotal = 0;
            
            function test(name, testFn) {
                testsTotal++;
                console.log(`Testing: ${name}`);
                try {
                    const result = testFn();
                    if (result instanceof Promise) {
                        return result.then(() => {
                            console.log('✅ PASS\n');
                            testsPassed++;
                        }).catch(error => {
                            console.log('❌ FAIL:', error.message, '\n');
                        });
                    } else {
                        console.log('✅ PASS\n');
                        testsPassed++;
                    }
                } catch (error) {
                    console.log('❌ FAIL:', error.message, '\n');
                }
            }
            
            // Test 1: Normal expense saving with all improvements
            await test('Normal expense saving should work with all improvements', () => {
                setupTestEnvironment();
                
                const expense = getMockExpense();
                const expenseId = App.addExpense(expense);
                
                if (!expenseId) throw new Error('addExpense returned no ID');
                if (!App.currentProject.expenses[expenseId]) throw new Error('Expense not added to project');
                
                // Check it was saved to cache with dirty flag
                const cachedProject = Cache.getProject(App.currentProject.id);
                if (!cachedProject.data.expenses[expenseId]) throw new Error('Expense not saved to cache');
                if (!cachedProject.dirty) throw new Error('Project not marked as dirty');
                
                // Check data integrity
                const savedExpense = cachedProject.data.expenses[expenseId];
                if (savedExpense.amount !== expense.amount) throw new Error('Amount not preserved');
                if (savedExpense.description !== expense.description) throw new Error('Description not preserved');
                
                console.log('✓ Expense saved correctly with dirty flag');
                console.log('✓ Data integrity preserved');
            });
            
            // Test 2: Error handling and rollback
            await test('Should handle errors with proper feedback and rollback', () => {
                setupTestEnvironment();
                
                // Test with invalid expense data
                try {
                    App.addExpense(null);
                    throw new Error('Should have thrown error for null expense');
                } catch (error) {
                    if (!error.message.includes('Invalid expense data')) {
                        throw new Error('Wrong error message: ' + error.message);
                    }
                }
                
                // Test with missing required fields
                try {
                    App.addExpense({ description: 'Test' }); // Missing amount and paidBy
                    throw new Error('Should have thrown error for missing fields');
                } catch (error) {
                    if (!error.message.includes('Missing required expense fields')) {
                        throw new Error('Wrong error message: ' + error.message);
                    }
                }
                
                console.log('✓ Proper error handling for invalid data');
                console.log('✓ Appropriate error messages shown');
            });
            
            // Test 3: Data recovery and backup system
            await test('Should create backups and handle data recovery', () => {
                setupTestEnvironment();
                
                const expense = getMockExpense();
                const expenseId = App.addExpense(expense);
                
                // Check that backups were created
                const backupKeys = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('fairsplit_backup_')) {
                        backupKeys.push(key);
                    }
                }
                
                if (backupKeys.length === 0) throw new Error('No backups were created');
                
                // Test recovery functionality
                const recovered = Utils.recoverFromBackup(App.currentProject.id);
                if (!recovered) throw new Error('Failed to recover from backup');
                if (!recovered.expenses[expenseId]) throw new Error('Expense not found in recovered data');
                
                console.log('✓ Backup system working');
                console.log('✓ Data recovery functional');
                console.log(`✓ Created ${backupKeys.length} backup(s)`);
            });
            
            // Test 4: Data integrity validation and cleaning
            await test('Should validate and clean corrupted data', () => {
                setupTestEnvironment();
                
                // Add a valid expense first
                const validExpense = getMockExpense();
                const validId = App.addExpense(validExpense);
                
                // Corrupt the project data
                const corruptedProject = structuredClone(App.currentProject);
                corruptedProject.expenses['corrupt-1'] = {
                    // Missing required fields
                    description: 'Corrupt expense'
                };
                corruptedProject.expenses['corrupt-2'] = {
                    description: 'Another corrupt expense',
                    amount: -50, // Invalid amount
                    paidBy: 'nonexistent-member'
                };
                
                // Test cleaning function
                const cleaned = Utils.cleanProjectData(corruptedProject);
                
                // Valid expense should still be there
                if (!cleaned.expenses[validId]) throw new Error('Valid expense was removed');
                
                // Corrupt expenses should be removed
                if (cleaned.expenses['corrupt-1']) throw new Error('Corrupt expense 1 was not removed');
                if (cleaned.expenses['corrupt-2']) throw new Error('Corrupt expense 2 was not removed');
                
                console.log('✓ Data validation working');
                console.log('✓ Corrupt data cleaned properly');
                console.log('✓ Valid data preserved');
            });
            
            // Test 5: Atomic operations prevent race conditions
            await test('Should handle atomic operations without race conditions', () => {
                setupTestEnvironment();
                
                const expense1 = getMockExpense({ description: 'Expense 1' });
                const expense2 = getMockExpense({ description: 'Expense 2' });
                
                // Add expenses rapidly
                const id1 = App.addExpense(expense1);
                const id2 = App.addExpense(expense2);
                
                if (id1 === id2) throw new Error('IDs should be unique');
                
                // Both should be saved with dirty flag
                const cachedProject = Cache.getProject(App.currentProject.id);
                if (!cachedProject.dirty) throw new Error('Project should be marked as dirty');
                if (!cachedProject.data.expenses[id1]) throw new Error('First expense not saved');
                if (!cachedProject.data.expenses[id2]) throw new Error('Second expense not saved');
                
                console.log('✓ Atomic operations working');
                console.log('✓ No race conditions detected');
                console.log('✓ Both expenses saved correctly');
            });
            
            // Test 6: Immediate sync trigger
            await test('Should trigger immediate sync for critical operations', async () => {
                setupTestEnvironment();
                
                // Mock the sync function to track calls
                let syncCalled = false;
                const originalSync = Sync.syncProjectImmediately;
                Sync.syncProjectImmediately = async (projectId) => {
                    syncCalled = true;
                    return true;
                };
                
                const expense = getMockExpense();
                const expenseId = App.addExpense(expense);
                
                // Wait a bit for async sync call
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Restore original function
                Sync.syncProjectImmediately = originalSync;
                
                if (!syncCalled) throw new Error('Immediate sync was not triggered');
                
                console.log('✓ Immediate sync triggered');
                console.log('✓ Critical operations prioritized');
            });
            
            console.log(`\n=== Test Results: ${testsPassed}/${testsTotal} passed ===`);
            
            if (testsPassed === testsTotal) {
                console.log('\n🎉 All tests passed! Expense saving issues are fixed.');
                console.log('\nKey improvements implemented:');
                console.log('- ✅ Comprehensive error handling');
                console.log('- ✅ Atomic cache operations');
                console.log('- ✅ Data validation and recovery');
                console.log('- ✅ Automatic backups');
                console.log('- ✅ Immediate sync for critical operations');
                console.log('- ✅ Optimistic UI updates with rollback');
            } else {
                console.log('\n⚠️  Some tests failed - additional work may be needed');
            }
        }
    </script>
</body>
</html>